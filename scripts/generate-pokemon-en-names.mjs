// Generates English Pokémon name map for this app from yakkun.com (SV English name list).
//
// Why:
// - We want JP/EN toggle without calling external APIs at runtime.
// - yakkun is simple and sufficient as a source, but direct Node fetch may be blocked.
//   On Windows, `curl.exe` currently succeeds, so we use it to download raw HTML.
//
// Output:
// - src/domain/pokesleep/_generated/pokemon-name-en.ts
//
// Usage:
// - node scripts/generate-pokemon-en-names.mjs
//
// Notes:
// - The source page is EUC-JP. We only need ASCII parts (dex no / English names),
//   so we parse the HTML as a binary/latin1 string and ignore Japanese text.
import fs from "node:fs";
import path from "node:path";
import { execFileSync } from "node:child_process";

const ROOT = process.cwd();
const SOURCE_URL = "https://yakkun.com/sv/pokemon_en.htm";
const CACHE_PATH = path.join(ROOT, "_local", "yakkun_pokemon_en.htm");
const OUT_PATH = path.join(ROOT, "src", "domain", "pokesleep", "_generated", "pokemon-name-en.ts");
const MASTER_PATH = path.join(ROOT, "src", "domain", "pokesleep", "pokemon-master.ts");

// --force オプションでキャッシュを強制クリア
const forceRefresh = process.argv.includes("--force");

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function downloadIfMissing() {
  ensureDir(path.dirname(CACHE_PATH));

  // --force の場合はキャッシュを削除
  if (forceRefresh && fs.existsSync(CACHE_PATH)) {
    fs.unlinkSync(CACHE_PATH);
    console.log("[generate-pokemon-en-names] キャッシュを削除しました");
  }

  if (fs.existsSync(CACHE_PATH) && fs.statSync(CACHE_PATH).size > 1000) return;


  // Prefer curl.exe on Windows (PowerShell has curl alias).
  const curlCmd = process.platform === "win32" ? "curl.exe" : "curl";
  const args = [
    "-L",
    "-A",
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36",
    "-H",
    "Accept-Language: ja,en;q=0.9",
    "-H",
    "Accept: text/html,application/xhtml+xml",
    "-o",
    CACHE_PATH,
    SOURCE_URL,
  ];
  execFileSync(curlCmd, args, { stdio: "inherit" });
}

function readTargetDexNosFromMaster() {
  const txt = fs.readFileSync(MASTER_PATH, "utf8");
  const re = /"pokedexId"\s*:\s*(\d+)/g;
  const set = new Set();
  for (; ;) {
    const m = re.exec(txt);
    if (!m) break;
    set.add(Number(m[1]));
  }
  return set;
}

function decodeHtmlEntities(s) {
  return String(s)
    .replace(/&nbsp;/g, " ")
    .replace(/&amp;/g, "&")
    .replace(/&quot;/g, '"')
    .replace(/&#39;/g, "'")
    .replace(/&lt;/g, "<")
    .replace(/&gt;/g, ">")
    .replace(/&#(\d+);/g, (_, n) => String.fromCodePoint(Number(n)));
}

function parseEnNamesFromHtmlBinary(html) {
  // Example row:
  // <tr><td class="c1">001</td><td ...>JP</td><td>Bulbasaur</td></tr>
  const out = new Map(); // dexNo -> enName
  const re = /<tr>\s*<td class="c1">(\d+)<\/td>\s*<td[^>]*>[\s\S]*?<\/td>\s*<td>([\s\S]*?)<\/td>\s*<\/tr>/g;
  for (; ;) {
    const m = re.exec(html);
    if (!m) break;
    const dexNo = Number(m[1]);
    const enRaw = decodeHtmlEntities(m[2]).trim();
    const en = enRaw.replace(/\s+/g, " ");
    if (!dexNo || !en) continue;
    out.set(dexNo, en);
  }
  return out;
}

function emitTs(mapping) {
  const keys = [...mapping.keys()].sort((a, b) => a - b);
  const lines = [];
  lines.push(`// This file is auto-generated by scripts/generate-pokemon-en-names.mjs`);
  lines.push(`// Source: ${SOURCE_URL}`);
  lines.push(`// Generated at: ${new Date().toISOString()}`);
  lines.push("");
  lines.push(`export const pokemonNameEnByDexNo: Record<number, string> = {`);
  for (const k of keys) {
    const v = mapping.get(k);
    const safe = JSON.stringify(v);
    lines.push(`  ${k}: ${safe},`);
  }
  lines.push(`};`);
  lines.push("");
  lines.push(`export function getPokemonNameEnByDexNo(dexNo: number): string | null {`);
  lines.push(`  const v = (pokemonNameEnByDexNo as any)[Number(dexNo)];`);
  lines.push(`  return typeof v === "string" ? v : null;`);
  lines.push(`}`);
  lines.push("");
  return lines.join("\n");
}

function readExistingDexNos() {
  if (!fs.existsSync(OUT_PATH)) return new Set();
  const txt = fs.readFileSync(OUT_PATH, "utf8");
  const re = /^\s*(\d+):/gm;
  const set = new Set();
  for (; ;) {
    const m = re.exec(txt);
    if (!m) break;
    set.add(Number(m[1]));
  }
  return set;
}

function main() {
  downloadIfMissing();
  const targetDexNos = readTargetDexNosFromMaster();
  const existingDexNos = readExistingDexNos();
  const buf = fs.readFileSync(CACHE_PATH);
  const html = buf.toString("latin1"); // keep ASCII intact; ignore JP text
  const all = parseEnNamesFromHtmlBinary(html);

  const filtered = new Map();
  for (const dexNo of targetDexNos) {
    const en = all.get(dexNo);
    if (en) filtered.set(dexNo, en);
  }

  // 新規追加されたエントリを検出
  const newEntries = [];
  for (const dexNo of filtered.keys()) {
    if (!existingDexNos.has(dexNo)) {
      newEntries.push({ dexNo, en: filtered.get(dexNo) });
    }
  }
  newEntries.sort((a, b) => a.dexNo - b.dexNo);

  ensureDir(path.dirname(OUT_PATH));
  fs.writeFileSync(OUT_PATH, emitTs(filtered), "utf8");

  const missing = [...targetDexNos].filter((n) => !filtered.has(n)).sort((a, b) => a - b);
  if (missing.length) {
    // eslint-disable-next-line no-console
    console.warn(`[generate-pokemon-en-names] Missing ${missing.length} dexNos: ${missing.slice(0, 20).join(", ")}${missing.length > 20 ? "..." : ""}`);
  }

  // 新規追加を表示
  if (newEntries.length) {
    // eslint-disable-next-line no-console
    console.log(`\n[generate-pokemon-en-names] 新規追加: ${newEntries.length}件`);
    for (const { dexNo, en } of newEntries) {
      // eslint-disable-next-line no-console
      console.log(`  #${dexNo} ${en}`);
    }
  }

  // eslint-disable-next-line no-console
  console.log(`[generate-pokemon-en-names] Wrote ${filtered.size} entries to ${path.relative(ROOT, OUT_PATH)}`);
}

main();
