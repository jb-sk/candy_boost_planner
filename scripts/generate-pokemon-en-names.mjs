// Generates English PokÃ©mon name map for this app from PokeAPI.
//
// Why:
// - We want JP/EN toggle without calling external APIs at runtime.
// - PokeAPI is a free, stable REST API that doesn't require JavaScript execution.
//
// Output:
// - src/domain/pokesleep/_generated/pokemon-name-en.ts
//
// Usage:
// - node scripts/generate-pokemon-en-names.mjs              (use cache, fetch new only)
// - node scripts/generate-pokemon-en-names.mjs --refresh    (ignore cache, re-fetch all, write only if changed)
// - node scripts/generate-pokemon-en-names.mjs --force      (clear cache + re-fetch all + always write)
//
// Notes:
// - Uses PokeAPI /pokemon-species/{id} endpoint to get English names.
// - Caches results in _local/pokeapi-cache.json to avoid repeated API calls.
// - Rate limit: 100ms delay between requests.
// - Safety: Aborts if 5+ requests fail.

import fs from "node:fs";
import path from "node:path";

const ROOT = process.cwd();
const CACHE_PATH = path.join(ROOT, "_local", "pokeapi-cache.json");
const OUT_PATH = path.join(ROOT, "src", "domain", "pokesleep", "_generated", "pokemon-name-en.ts");
const MASTER_PATH = path.join(ROOT, "src", "domain", "pokesleep", "pokemon-master.ts");

const POKEAPI_BASE = "https://pokeapi.co/api/v2/pokemon-species";
const RATE_LIMIT_MS = 100;
const MAX_FAILURES = 5;

// Options
const forceWrite = process.argv.includes("--force");       // Clear cache + always write
const refreshAll = process.argv.includes("--refresh") || forceWrite;  // Re-fetch all (ignore cache)

function ensureDir(p) {
  fs.mkdirSync(p, { recursive: true });
}

function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

/**
 * Load cache from disk.
 * @returns {Map<number, string>} dexNo -> enName
 */
function loadCache() {
  if (forceWrite) {
    console.log("[generate-pokemon-en-names] --force: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™");
    return new Map();
  }
  if (refreshAll) {
    console.log("[generate-pokemon-en-names] --refresh: ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’ç„¡è¦–ã—ã¦å…¨ä»¶å†å–å¾—ã—ã¾ã™");
    // Return empty map to force re-fetch, but don't delete cache file
    // (cache will be updated with fresh values after fetch)
    return new Map();
  }
  if (!fs.existsSync(CACHE_PATH)) {
    return new Map();
  }
  try {
    const json = JSON.parse(fs.readFileSync(CACHE_PATH, "utf8"));
    const map = new Map();
    for (const [k, v] of Object.entries(json)) {
      map.set(Number(k), v);
    }
    console.log(`[generate-pokemon-en-names] ã‚­ãƒ£ãƒƒã‚·ãƒ¥èª­ã¿è¾¼ã¿: ${map.size}ä»¶`);
    return map;
  } catch {
    return new Map();
  }
}

/**
 * Save cache to disk.
 * @param {Map<number, string>} map
 */
function saveCache(map) {
  ensureDir(path.dirname(CACHE_PATH));
  const obj = {};
  for (const [k, v] of [...map.entries()].sort((a, b) => a[0] - b[0])) {
    obj[k] = v;
  }
  fs.writeFileSync(CACHE_PATH, JSON.stringify(obj, null, 2), "utf8");
}

/**
 * Read target dexNos from pokemon-master.ts.
 * @returns {Set<number>}
 */
function readTargetDexNosFromMaster() {
  const txt = fs.readFileSync(MASTER_PATH, "utf8");
  const re = /"pokedexId"\s*:\s*(\d+)/g;
  const set = new Set();
  for (; ;) {
    const m = re.exec(txt);
    if (!m) break;
    set.add(Number(m[1]));
  }
  return set;
}

/**
 * Read existing dexNos from output file.
 * @returns {Map<number, string>} dexNo -> enName
 */
function readExistingEnNames() {
  if (!fs.existsSync(OUT_PATH)) return new Map();
  const txt = fs.readFileSync(OUT_PATH, "utf8");
  const re = /^\s*(\d+):\s*"([^"]+)"/gm;
  const map = new Map();
  for (; ;) {
    const m = re.exec(txt);
    if (!m) break;
    map.set(Number(m[1]), m[2]);
  }
  return map;
}

/**
 * Fetch English name from PokeAPI.
 * @param {number} dexNo
 * @returns {Promise<string | null>}
 */
async function fetchEnNameFromPokeAPI(dexNo) {
  const url = `${POKEAPI_BASE}/${dexNo}`;
  try {
    const res = await fetch(url);
    if (!res.ok) {
      console.warn(`  âš ï¸ #${dexNo}: HTTP ${res.status}`);
      return null;
    }
    const data = await res.json();
    const enEntry = data.names?.find((n) => n.language?.name === "en");
    if (!enEntry) {
      console.warn(`  âš ï¸ #${dexNo}: è‹±èªåãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“`);
      return null;
    }
    return enEntry.name;
  } catch (err) {
    console.warn(`  âš ï¸ #${dexNo}: ${err.message}`);
    return null;
  }
}

/**
 * Emit TypeScript file.
 * @param {Map<number, string>} mapping
 */
function emitTs(mapping) {
  const keys = [...mapping.keys()].sort((a, b) => a - b);
  const lines = [];
  lines.push(`// This file is auto-generated by scripts/generate-pokemon-en-names.mjs`);
  lines.push(`// Source: PokeAPI (https://pokeapi.co/)`);
  lines.push(`// Generated at: ${new Date().toISOString()}`);
  lines.push("");
  lines.push(`export const pokemonNameEnByDexNo: Record<number, string> = {`);
  for (const k of keys) {
    const v = mapping.get(k);
    const safe = JSON.stringify(v);
    lines.push(`  ${k}: ${safe},`);
  }
  lines.push(`};`);
  lines.push("");
  lines.push(`export function getPokemonNameEnByDexNo(dexNo: number): string | null {`);
  lines.push(`  const v = (pokemonNameEnByDexNo as any)[Number(dexNo)];`);
  lines.push(`  return typeof v === "string" ? v : null;`);
  lines.push(`}`);
  lines.push("");
  return lines.join("\n");
}

async function main() {
  console.log("[generate-pokemon-en-names] PokeAPI ã‹ã‚‰è‹±èªåã‚’å–å¾—ã—ã¾ã™\n");

  const targetDexNos = readTargetDexNosFromMaster();
  console.log(`å¯¾è±¡ãƒã‚±ãƒ¢ãƒ³: ${targetDexNos.size}ä»¶\n`);

  const existingNames = readExistingEnNames();
  const cache = loadCache();

  const result = new Map();
  let failCount = 0;
  let fetchCount = 0;

  const sortedDexNos = [...targetDexNos].sort((a, b) => a - b);

  for (const dexNo of sortedDexNos) {
    // Check cache first
    if (cache.has(dexNo)) {
      result.set(dexNo, cache.get(dexNo));
      continue;
    }

    // Fetch from PokeAPI
    console.log(`  Fetching #${dexNo}...`);
    const enName = await fetchEnNameFromPokeAPI(dexNo);

    if (enName) {
      result.set(dexNo, enName);
      cache.set(dexNo, enName);
      fetchCount++;
    } else {
      failCount++;
      console.warn(`  âŒ #${dexNo} å–å¾—å¤±æ•— (${failCount}/${MAX_FAILURES})`);

      if (failCount >= MAX_FAILURES) {
        console.error(`\nâŒ ${MAX_FAILURES}ä»¶ä»¥ä¸Šå¤±æ•—ã—ã¾ã—ãŸã€‚æ›´æ–°ã‚’ä¸­æ–­ã—ã¾ã™ã€‚`);
        process.exit(1);
      }
    }

    await delay(RATE_LIMIT_MS);
  }

  // Save cache
  saveCache(cache);

  // Detect added/removed/changed
  const added = [];
  const removed = [];
  const changed = [];

  for (const [dexNo, enName] of result) {
    if (!existingNames.has(dexNo)) {
      added.push({ dexNo, enName });
    } else if (existingNames.get(dexNo) !== enName) {
      changed.push({ dexNo, oldName: existingNames.get(dexNo), newName: enName });
    }
  }

  for (const [dexNo, enName] of existingNames) {
    if (!result.has(dexNo)) {
      removed.push({ dexNo, enName });
    }
  }

  const hasChanges = added.length > 0 || removed.length > 0 || changed.length > 0;

  // Log changes
  console.log("");
  if (added.length > 0) {
    console.log(`âœ… è¿½åŠ : ${added.length}ä»¶`);
    for (const { dexNo, enName } of added.sort((a, b) => a.dexNo - b.dexNo)) {
      console.log(`   #${dexNo} ${enName}`);
    }
  }

  if (changed.length > 0) {
    console.log(`ğŸ“ å¤‰æ›´: ${changed.length}ä»¶`);
    for (const { dexNo, oldName, newName } of changed.sort((a, b) => a.dexNo - b.dexNo)) {
      console.log(`   #${dexNo} ${oldName} â†’ ${newName}`);
    }
  }

  if (removed.length > 0) {
    console.log(`ğŸ—‘ï¸ å‰Šé™¤: ${removed.length}ä»¶`);
    for (const { dexNo, enName } of removed.sort((a, b) => a.dexNo - b.dexNo)) {
      console.log(`   #${dexNo} ${enName}`);
    }
  }

  if (!hasChanges) {
    console.log(`å¤‰æ›´ãªã—`);
  }

  // Write output (only if content changed, unless --force)
  ensureDir(path.dirname(OUT_PATH));
  const newContent = emitTs(result);
  const oldContent = fs.existsSync(OUT_PATH) ? fs.readFileSync(OUT_PATH, "utf8") : "";

  // Compare without timestamp line
  const stripTimestamp = (s) => s.replace(/^\/\/ Generated at:.*$/m, "");
  const contentChanged = stripTimestamp(newContent) !== stripTimestamp(oldContent);

  if (forceWrite || contentChanged) {
    fs.writeFileSync(OUT_PATH, newContent, "utf8");
    if (!contentChanged) {
      console.log("[generate-pokemon-en-names] --force: å¤‰æ›´ãªã—ã§ã™ãŒãƒ•ã‚¡ã‚¤ãƒ«ã‚’æ›´æ–°ã—ã¾ã—ãŸ");
    }
  } else {
    console.log("[generate-pokemon-en-names] ãƒ•ã‚¡ã‚¤ãƒ«å†…å®¹ã«å¤‰æ›´ãªã—ï¼ˆæ›¸ãè¾¼ã¿ã‚¹ã‚­ãƒƒãƒ—ï¼‰");
  }

  const missing = [...targetDexNos].filter((n) => !result.has(n)).sort((a, b) => a - b);
  if (missing.length > 0) {
    console.warn(`\nâš ï¸ å–å¾—ã§ããªã‹ã£ãŸ: ${missing.length}ä»¶: ${missing.slice(0, 20).join(", ")}${missing.length > 20 ? "..." : ""}`);
  }

  console.log(`\n[generate-pokemon-en-names] å®Œäº†: ${result.size}ä»¶ â†’ ${path.relative(ROOT, OUT_PATH)}`);
  if (fetchCount > 0) {
    console.log(`  (æ–°è¦å–å¾—: ${fetchCount}ä»¶, ã‚­ãƒ£ãƒƒã‚·ãƒ¥åˆ©ç”¨: ${result.size - fetchCount}ä»¶)`);
  }

  // Output summary line for CI parsing
  console.log(`\n[SUMMARY] has_changes=${hasChanges} added=${added.length} changed=${changed.length} removed=${removed.length}`);
}

main();
