import fs from "node:fs";
import path from "node:path";
import { fileURLToPath } from "node:url";
import * as cheerio from "cheerio";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DEFAULT_URL =
  "https://wikiwiki.jp/poke_sleep/%E5%A4%9A%E8%A8%80%E8%AA%9E%E3%81%AE%E5%90%8D%E8%A9%9E%E3%83%BB%E7%94%A8%E8%AA%9E%E3%81%AE%E4%B8%80%E8%A6%A7";

function parseArgs(argv) {
  const out = {
    url: DEFAULT_URL,
    outFile: path.join(__dirname, "../src/i18n/_generated/terms.ts"),
  };
  for (let i = 2; i < argv.length; i++) {
    const a = argv[i];
    if (a === "--url" && argv[i + 1]) {
      out.url = argv[i + 1];
      i++;
      continue;
    }
    if ((a === "--out" || a === "--out-file") && argv[i + 1]) {
      out.outFile = argv[i + 1];
      i++;
      continue;
    }
  }
  return out;
}

const args = parseArgs(process.argv);

function normText(s) {
  return String(s ?? "")
    .replace(/\u00a0/g, " ")
    .replace(/[ \t\r\n]+/g, " ")
    .trim();
}

function closestSectionTitle($, tableEl) {
  // tableの直前にある見出しを拾う（h2/h3/h4）
  const $table = $(tableEl);
  let node = $table.prev();
  for (let i = 0; i < 40; i++) {
    if (!node || node.length === 0) break;
    const tag = (node.get(0)?.tagName ?? "").toLowerCase();
    if (tag === "h2" || tag === "h3" || tag === "h4") {
      const t = normText(node.text());
      if (t) return t;
    }
    node = node.prev();
  }
  return "";
}

function pickHeaderRow($, tableEl) {
  const rows = $(tableEl).find("tr").toArray();
  const headerRow = rows.find((tr) => $(tr).find("th").length > 0) ?? rows[0];
  return headerRow ?? null;
}

function findLangCols(headers) {
  const ja = headers.findIndex((h) => /日本語|Japanese/i.test(h));
  const en = headers.findIndex((h) => /英語|English/i.test(h));
  return { ja: ja >= 0 ? ja : null, en: en >= 0 ? en : null };
}

function extractPairsFromTable($, tableEl) {
  const headerRow = pickHeaderRow($, tableEl);
  if (!headerRow) return null;
  const headers = $(headerRow)
    .find("th,td")
    .map((_, el) => normText($(el).text()))
    .get();
  const { ja: jaCol, en: enCol } = findLangCols(headers);
  if (jaCol === null || enCol === null) return null;

  const out = [];
  const rows = $(tableEl).find("tr").toArray();
  for (const tr of rows) {
    const cells = $(tr).find("th,td").toArray();
    if (!cells.length) continue;
    const ja = normText($(cells[jaCol] ?? "").text());
    const en = normText($(cells[enCol] ?? "").text());
    if (!ja || !en) continue;
    // header行っぽいものは除外
    if (ja === "日本語" && en === "英語") continue;
    out.push([ja, en]);
  }
  return { headers, pairs: out };
}

function toObj(pairs) {
  const obj = {};
  for (const [ja, en] of pairs) {
    // 重複は先勝ち（後勝ちだと表の順序に左右されやすい）
    if (!obj[ja]) obj[ja] = en;
  }
  return obj;
}

const res = await fetch(args.url, {
  headers: { "User-Agent": "candy-boost-planner (generate-terms)" },
});
if (!res.ok) throw new Error(`Fetch failed: ${res.status} ${res.statusText}`);
const html = await res.text();
const $ = cheerio.load(html);

const wanted = [
  { key: "subSkills", re: /サブスキル/i },
  { key: "ingredients", re: /食材/i },
  { key: "berries", re: /きのみ/i },
  { key: "types", re: /タイプ|属性/i },
  { key: "natures", re: /せいかく|性格/i },
];

const buckets = {
  subSkills: [],
  ingredients: [],
  berries: [],
  types: [],
  natures: [],
  other: [],
};

const tables = $("table").toArray();
for (const tbl of tables) {
  const extracted = extractPairsFromTable($, tbl);
  if (!extracted || extracted.pairs.length < 3) continue;
  const title = closestSectionTitle($, tbl);
  const bucket = wanted.find((w) => w.re.test(title))?.key ?? "other";
  buckets[bucket].push(...extracted.pairs);
}

const generatedAt = new Date().toISOString();
const outPath = path.resolve(args.outFile);
fs.mkdirSync(path.dirname(outPath), { recursive: true });

const content =
  `// This file is auto-generated by scripts/generate-terms.mjs\n` +
  `// Source: ${args.url}\n` +
  `// Generated at: ${generatedAt}\n\n` +
  `export const termJaToEn = ${JSON.stringify(toObj([].concat(...Object.values(buckets))), null, 2)} as const;\n`;

fs.writeFileSync(outPath, content, "utf8");
console.log(`[generate-terms] wrote: ${outPath}`);
console.log(
  `[generate-terms] counts: subSkills=${buckets.subSkills.length} ingredients=${buckets.ingredients.length} berries=${buckets.berries.length} types=${buckets.types.length} natures=${buckets.natures.length}`
);
